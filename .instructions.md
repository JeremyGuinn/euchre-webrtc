

# AI_INSTRUCTIONS.md

## Overview

You are tasked with creating a **peer-to-peer online Euchre game** using **React 19**, **react-router 7**, and **pnpm** as the package manager. The entire application runs in the **frontend**, and uses **WebRTC via the PeerJS library** for peer-to-peer communication.

This document outlines how to structure and implement the application to meet the user experience, robustness, and game architecture requirements.

---

## ‚ú® Goals

- Enable friends to play Euchre together online with **zero backend**.
- Prioritize **intuitive user experience**, clean design, and responsive gameplay.
- Ensure **robust reconnection handling** and enforce **light peer-side message integrity**.
- Use **binary protocol communication** over PeerJS data channels.

---

## üß± Tech Stack

| Concern              | Tool/Library        |
|----------------------|---------------------|
| Framework            | React 19            |
| Routing              | react-router 7      |
| State Management     | React Context / useReducer (preferred) |
| P2P Communication    | PeerJS (WebRTC)     |
| Binary Protocol      | MessagePack (or similar) |
| Package Manager      | pnpm                |

---

## üö¶ Core Functional Requirements

### Hosting & Joining

- Host initializes a PeerJS connection and receives a `hostId`.
- Players join by entering `hostId`; host accepts and tracks connections.
- Lobby page reflects connected players.

### Game Flow

- Host initializes the deck, assigns teams, and controls dealer rotation.
- Players receive only public info and their private hands.
- Card plays are transmitted through host ‚Üí validated ‚Üí broadcasted.

### Networking Rules

- All messages are sent over PeerJS `dataConnection.send()`.
- Use a **binary protocol** (MessagePack) to minimize payload size.
- Every message includes:
  - `type`: string (e.g., `JOIN`, `DEAL`, `PLAY_CARD`)
  - `senderId`: unique peer id
  - `payload`: binary-encoded data
- The **host is the source of truth** for game state transitions.

---

## üõ°Ô∏è Resilience & Security Practices

- Players reconnect using their last known ID (store in `sessionStorage`).
- On reconnect, players request to resync state from host.
- Detect and reject spoofed or misrouted messages.
- Never expose full hand state to any peer except its owner.
- While the host can technically inspect cards, do not expose this via UI.

---

## üß† UX & UI

- Minimalist card table layout using intuitive drag/click mechanics.
- Highlight active player, trick-in-progress, and trump suit.
- Handle disconnects with banners and retry attempts.
- Animations should be smooth but non-blocking.

---

## üß™ Dev Tips

- Build game logic in isolation before wiring to PeerJS.
- Use an in-memory simulation to test reducers and state transitions.
- Keep UI and network code decoupled using events and message handlers.

---

## ‚úÖ Stretch Goals

- Support variant rules: ‚ÄúStick the Dealer‚Äù, ‚ÄúScrew the Dealer‚Äù
- Add persistent match history in local storage
- Animate card movement and trick wins
- Spectator mode (read-only peer)

---

## ‚ö†Ô∏è Anti-Goals

- Do not implement user authentication or backend
- Do not use any server-based signaling (rely on PeerJS default broker)